/*******************************************************************************
*  event.C                                                                  *
*	   - Translates the input from differnet SDL-devices to Egoboo-Events      *
*                                                                              *
*   EGOBOO			                                                         *
*       Copyright (C) 2009  The Egoboo Team                                    *
*                                                                              *
*   This program is free software; you can redistribute it and/or modify       *
*   it under the terms of the GNU General Public License as published by       *
*   the Free Software Foundation; either version 2 of the License, or          *
*   (at your option) any later version.                                        *
*                                                                              *
*   This program is distributed in the hope that it will be useful,            *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of             *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
*   GNU Library General Public License for more details.                       *
*                                                                              *
*   You should have received a copy of the GNU General Public License          *
*   along with this program; if not, write to the Free Software                *
*   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *
*******************************************************************************/


/*******************************************************************************
* INCLUDES								                                   *
*******************************************************************************/

#include <sdl.h>
#include <memory.h>     /* memset()     */
#include <string.h>     /* strcmp()     */
#include <ctype.h>      /* toupper()    */



#include "egocodes.h"   /* LATCHBUTTON... */


#include "event.h"

/*******************************************************************************
* DEFINES 								                                  *
*******************************************************************************/

#define EVENT_MAXLAG      64   /* ==> 'MAXLAG' */
#define EVENT_MAXPLAYER    8   /* Just to hold it short ==> MAXPLAYER */
#define EVENT_MAXCOMMAND 128   /* Maximum number of commands for players */

/* Special 'keys': Conversion of Input-Bits into 'keys' */
/* Mouse 'keys' */
#define EVENT_MOU_MIDDLE  3001
#define EVENT_MOU_RIGHT   3002
#define EVENT_MOU_LEFT    3003
#define EVENT_MOU_FOURTH  3004
#define EVENT_MOU_MOVE    3005    /* Mouse has moved */
#define EVENT_MOU_LDRAG   3006
#define EVENT_MOU_RDRAG   3007

/* Joystick A 'keys' */
#define EVENT_JOY_A_0 4000
#define EVENT_JOY_A_1 4001
#define EVENT_JOY_A_2 4002
#define EVENT_JOY_A_3 4003
#define EVENT_JOY_A_4 4004
#define EVENT_JOY_A_5 4005
#define EVENT_JOY_A_6 4006
#define EVENT_JOY_A_7 4007
#define EVENT_JOY_A_MOVE 4019
/* Joystick B 'keys' */
#define EVENT_JOY_B_0 4020
#define EVENT_JOY_B_1 4021
#define EVENT_JOY_B_2 4022
#define EVENT_JOY_B_3 4023
#define EVENT_JOY_B_4 4024
#define EVENT_JOY_B_5 4025
#define EVENT_JOY_B_6 4026
#define EVENT_JOY_B_7 4027
#define EVENT_JOY_B_MOVE 4039

/* -------- Special flag for combined keys */
#define EVENT_CMD_FPRESELECT  0x01
#define EVENT_CMD_FPOSTSELECT 0x02


/*******************************************************************************
* TYPEDEFS								                                       *
*******************************************************************************/

typedef struct {

    char  valid;        /* Player used ? ==> plavalid                   */
    int   index;        /* Which character? ==> plaindex                */ 
                        /* Relative movement, generated by input device */
    float latchx;       /* Local latches ==> plalatchx                  */                    
    float latchy;       /* ==> plalatchy                                */
    unsigned int latchbutton;  /* Bitflags, generated by input device   */
    float dist;         /* Distance moved, adjusted to inputdevice      */
    char network;       /* Player is from network true/false            */
    char cameramode;    /* This input is in camera mode, yes/no         */

} PLAYER;

typedef struct {

    char name[18];  /* replaces: char tagname[MAXTAG][TAGSIZE]; -> Scancode names  */
    int  sdl_code;  /* replaces: unsigned int tagvalue[MAXTAG]; -> Scancode values */
                    /* The scancode or mask ==> SDL-Code				           */

} CONTROL_NAME;

typedef struct {

    SDL_Joystick *sdl_device;
    int          on;                     /* < Is the holy joystick live? */
    int          index; 

} EVENT_JOYSTICK;

typedef struct {
    
    int sdlkey;
    char shiftkey;

} EVENT_SHIFTVAL;

/*******************************************************************************
* DATA								                                       *
*******************************************************************************/

/* --------- Pointer on lists which are used to translate input to commands */
static EVENT_JOYSTICK JoyStick[2];
static EVENT_RANGE *pRanges;        /* Pointer on ranges to check, if any   */
static EVENT_CMD   *pCmdList;       /* Pointer on commands to check, if any */

static EVENT_RANGE DefaultFocusRange;
static EVENT_RANGE *EventFocus = &DefaultFocusRange;    /* Focus / Mouse button pressed */

/* ------- Table for special cases of shift-values ------ */
static EVENT_SHIFTVAL Shift_Char_Lut[] = {

    { SDLK_1, '!' },
    { SDLK_2, '@' },
    { SDLK_3, '#' },
    { SDLK_4, '$' },
    { SDLK_5, '%' },
    { SDLK_6, '^' },
    { SDLK_7, '&' },
    { SDLK_8, '*' },
    { SDLK_9, '(' },
    { SDLK_0, ')' },
    { SDLK_QUOTE, '\"' },
    { SDLK_SPACE, ' ' },
    { SDLK_SEMICOLON, ':' },
    { SDLK_PERIOD, '>' },
    { SDLK_COMMA, '<' },
    { SDLK_BACKQUOTE, '`' },
    { SDLK_MINUS, '_' },
    { SDLK_EQUALS, '+' },
    { SDLK_LEFTBRACKET, '{' },
    { SDLK_RIGHTBRACKET, '}' },
    { SDLK_BACKSLASH, '|' },
    { SDLK_SLASH, '?' },
    { 0 }
  
};


static PLAYER Player[EVENT_MAXPLAYER + 2];   /* List of players      */
                                             /* (fed by INPUTDEVICE) */
                                                  
/* Control Table needed to translate from CONTROLS.CFG to SDL-Codes */
static CONTROL_NAME Control_Table[] = {

    { "KEY_ESCAPE", SDLK_ESCAPE },
    { "KEY_1", SDLK_1 },
    { "KEY_2", SDLK_2 },
    { "KEY_3", SDLK_3 },
    { "KEY_4", SDLK_4 },
    { "KEY_5", SDLK_5 },
    { "KEY_6", SDLK_6 },
    { "KEY_7", SDLK_7 },
    { "KEY_8", SDLK_8 },
    { "KEY_9", SDLK_9  },
    { "KEY_0", SDLK_0 },
    { "KEY_MINUS", SDLK_MINUS },
    { "KEY_EQUALS", SDLK_EQUALS  },
    { "KEY_BACK_SPACE", SDLK_BACKSPACE },
    { "KEY_TAB", SDLK_TAB },
    { "KEY_Q", SDLK_q },
    { "KEY_W", SDLK_w },
    { "KEY_E", SDLK_e },
    { "KEY_R", SDLK_r },
    { "KEY_T", SDLK_t },
    { "KEY_Y", SDLK_y },
    { "KEY_U", SDLK_u },
    { "KEY_I", SDLK_i },
    { "KEY_O", SDLK_o },
    { "KEY_P", SDLK_p },
    { "KEY_LEFT_BRACKET", SDLK_LEFTBRACKET },
    { "KEY_RIGHT_BRACKET", SDLK_RIGHTBRACKET },
    { "KEY_RETURN", SDLK_RETURN },
    { "KEY_ENTER", SDLK_KP_ENTER },
    { "KEY_LEFT_CONTROL", SDLK_LCTRL },
    { "KEY_A", SDLK_a },
    { "KEY_S", SDLK_s },
    { "KEY_D", SDLK_d },
    { "KEY_F", SDLK_f },
    { "KEY_G", SDLK_g },
    { "KEY_H", SDLK_h },
    { "KEY_J", SDLK_j },
    { "KEY_K", SDLK_k },
    { "KEY_L", SDLK_l },
    { "KEY_SEMICOLON", SDLK_SEMICOLON },
    { "KEY_APOSTROPHE", SDLK_QUOTE },
    { "KEY_GRAVE", SDLK_BACKQUOTE },
    { "KEY_LEFT_SHIFT", SDLK_LSHIFT },
    { "KEY_BACKSLASH",  SDLK_BACKSLASH },
    { "KEY_Z", SDLK_z },
    { "KEY_X", SDLK_x },
    { "KEY_C", SDLK_c },
    { "KEY_V", SDLK_v },
    { "KEY_B", SDLK_b },
    { "KEY_N", SDLK_n },
    { "KEY_M", SDLK_m },
    { "KEY_COMMA", SDLK_COMMA },
    { "KEY_PERIOD", SDLK_PERIOD },
    { "KEY_SLASH", SDLK_SLASH },
    { "KEY_RIGHT_SHIFT", SDLK_RSHIFT },
    { "KEY_PAD_ASTERISK", SDLK_KP_MULTIPLY},
    { "KEY_LEFT_ALT", SDLK_LALT },
    { "KEY_SPACE", SDLK_SPACE },
    { "KEY_CAPITAL", SDLK_CAPSLOCK },
    { "KEY_F1", SDLK_F1 },
    { "KEY_F2", SDLK_F2 },
    { "KEY_F3", SDLK_F3 },
    { "KEY_F4", SDLK_F4 },
    { "KEY_F5", SDLK_F5 },
    { "KEY_F6", SDLK_F6 },
    { "KEY_F7", SDLK_F7 },
    { "KEY_F8", SDLK_F8 },
    { "KEY_F9", SDLK_F9 },
    { "KEY_F10", SDLK_F10 },
    { "KEY_NUM_LOCK", SDLK_NUMLOCK },
    { "KEY_SCROLL_LOCK", SDLK_SCROLLOCK },
    { "KEY_PAD_7", SDLK_KP7 },
    { "KEY_PAD_8", SDLK_KP8 },
    { "KEY_PAD_9", SDLK_KP9 },
    { "KEY_PAD_MINUS", SDLK_KP_MINUS },
    { "KEY_PAD_4", SDLK_KP4 },
    { "KEY_PAD_5", SDLK_KP5 },
    { "KEY_PAD_6", SDLK_KP6 },
    { "KEY_PAD_PLUS", SDLK_KP_PLUS },
    { "KEY_PAD_1", SDLK_KP1 },
    { "KEY_PAD_2", SDLK_KP2 },
    { "KEY_PAD_3", SDLK_KP3 },
    { "KEY_PAD_0", SDLK_KP0 },
    { "KEY_PAD_PERIOD",SDLK_KP_PERIOD },
    { "KEY_F11", SDLK_F11 },
    { "KEY_F12", SDLK_F12 },
    { "KEY_PAD_ENTER", SDLK_KP_ENTER },
    { "KEY_RIGHT_CONTROL", SDLK_RCTRL },
    { "KEY_PAD_SLASH", SDLK_KP_DIVIDE },
    { "KEY_RIGHT_ALT", SDLK_RALT },
    { "KEY_HOME", SDLK_HOME },
    { "KEY_UP", SDLK_UP },
    { "KEY_PAGE_UP", SDLK_PAGEUP },
    { "KEY_LEFT", SDLK_LEFT },
    { "KEY_RIGHT", SDLK_RIGHT },
    { "KEY_END", SDLK_END },
    { "KEY_DOWN", SDLK_DOWN },
    { "KEY_PAGE_DOWN", SDLK_PAGEDOWN },
    { "KEY_INSERT", SDLK_INSERT },
    { "KEY_DELETE", SDLK_DELETE },
    /* Mouse 'keys' */
    { "MOS_MIDDLE", EVENT_MOU_MIDDLE },
    { "MOS_RIGHT", EVENT_MOU_RIGHT },
    { "MOS_LEFT", EVENT_MOU_LEFT },
    { "MOS_FOURTH", EVENT_MOU_FOURTH },
    { "MOS_MOVE", EVENT_MOU_MOVE },
    /* Joystick A 'keys' */
    { "JOY_A_0", EVENT_JOY_A_0 },
    { "JOY_A_1", EVENT_JOY_A_1 },
    { "JOY_A_2", EVENT_JOY_A_2 },
    { "JOY_A_3", EVENT_JOY_A_3 },
    { "JOY_A_4", EVENT_JOY_A_4 },
    { "JOY_A_5", EVENT_JOY_A_5 },
    { "JOY_A_6", EVENT_JOY_A_6 },
    { "JOY_A_7", EVENT_JOY_A_7 },
    { "JOY_A_MOVE", EVENT_JOY_A_MOVE },
    /* Joystick B 'keys' */
    { "JOY_B_0", EVENT_JOY_B_0 },
    { "JOY_B_1", EVENT_JOY_B_1 },
    { "JOY_B_2", EVENT_JOY_B_2 },
    { "JOY_B_3", EVENT_JOY_B_3 },
    { "JOY_B_4", EVENT_JOY_B_4 },
    { "JOY_B_5", EVENT_JOY_B_5 },
    { "JOY_B_6", EVENT_JOY_B_6 },
    { "JOY_B_7", EVENT_JOY_B_7 },
    { "JOY_B_MOVE", EVENT_JOY_B_MOVE },
    { "" }			/* Empty string signs end of array */

};

static EVENT_CMD Command_List[EVENT_MAXCOMMAND] = {

    /* --------- First are the standard-Commands --------- */
    { EGOCODE_QUITMODULE, 0, { SDLK_ESCAPE } },
    { EGOCODE_SCREENSHOT, 0, { SDLK_F11 } },
    { EGOCODE_PAUSEGAME,  0, { SDLK_F8 } },
    { EGOCODE_RESPAWN, 0, { SDLK_SPACE } },
    { EGOCODE_LIFECHEAT, 0, { SDLK_z, SDLK_1 } },
    { EGOCODE_GIVEEXPERIENCE, 1, { SDLK_x, SDLK_1 } },
    { EGOCODE_GIVEEXPERIENCE, 2, { SDLK_x, SDLK_2 } },
    { EGOCODE_MAPCHEAT, 0, { SDLK_LSHIFT, SDLK_m } },
    { EGOCODE_SHOWSTAT_LSHIFT, 1, { SDLK_LSHIFT, SDLK_1 } },
    { EGOCODE_SHOWSTAT_LSHIFT, 2, { SDLK_LSHIFT, SDLK_2 } },
    { EGOCODE_SHOWSTAT_LSHIFT, 3, { SDLK_LSHIFT, SDLK_3 } },
    { EGOCODE_SHOWSTAT_LSHIFT, 4, { SDLK_LSHIFT, SDLK_4 } },
    { EGOCODE_SHOWSTAT_LSHIFT, 5, { SDLK_LSHIFT, SDLK_5 } },
    { EGOCODE_SHOWSTAT_LSHIFT, 6, { SDLK_LSHIFT, SDLK_6 } },
    { EGOCODE_SHOWSTAT_LSHIFT, 7, { SDLK_LSHIFT, SDLK_7 } },
    { EGOCODE_SHOWSTAT_LCTRL, 1, { SDLK_LCTRL, SDLK_1 } },
    { EGOCODE_SHOWSTAT_LCTRL, 2, { SDLK_LCTRL, SDLK_2 } },
    { EGOCODE_SHOWSTAT_LCTRL, 3, { SDLK_LCTRL, SDLK_3 } },
    { EGOCODE_SHOWSTAT_LCTRL, 4, { SDLK_LCTRL, SDLK_4 } },
    { EGOCODE_SHOWSTAT_LCTRL, 5, { SDLK_LCTRL, SDLK_5 } },
    { EGOCODE_SHOWSTAT_LCTRL, 6, { SDLK_LCTRL, SDLK_6 } },
    { EGOCODE_SHOWSTAT_LCTRL, 7, { SDLK_LCTRL, SDLK_7 } },
    { EGOCODE_SHOWSTAT_LALT, 1, { SDLK_LALT, SDLK_1 } },
    { EGOCODE_SHOWSTAT_LALT, 2, { SDLK_LALT, SDLK_2 } },
    { EGOCODE_SHOWSTAT_LALT, 3, { SDLK_LALT, SDLK_3 } },
    { EGOCODE_SHOWSTAT_LALT, 4, { SDLK_LALT, SDLK_4 } },
    { EGOCODE_SHOWSTAT_LALT, 5, { SDLK_LALT, SDLK_5 } },
    { EGOCODE_SHOWSTAT_LALT, 6, { SDLK_LALT, SDLK_6 } },
    { EGOCODE_SHOWSTAT_LALT, 7, { SDLK_LALT, SDLK_7 } },
    { EGOCODE_SHOWSTAT, 1, { SDLK_1 } },
    { EGOCODE_SHOWSTAT, 2, { SDLK_2 } },
    { EGOCODE_SHOWSTAT, 3, { SDLK_3 } },
    { EGOCODE_SHOWSTAT, 4, { SDLK_4 } },
    { EGOCODE_SHOWSTAT, 5, { SDLK_5 } },
    { EGOCODE_SHOWSTAT, 6, { SDLK_6 } },
    { EGOCODE_SHOWSTAT, 7, { SDLK_7 } },
    /* Rest of buffer is for user-configured input */
    /* Fill in starts at first 'EGOCODE_JUMP' */
    /* Default values for Player[1], in case of error reading the 'controls' */
    { EGOCODE_JUMP,         1, { SDLK_KP0 } },
    { EGOCODE_LEFT_USE,     1, { SDLK_t  } },
    { EGOCODE_LEFT_GET,     1, { SDLK_g } },
    { EGOCODE_LEFT_PACK,    1, { SDLK_b } },
    { EGOCODE_RIGHT_USE,    1, { SDLK_y } },
    { EGOCODE_RIGHT_GET,    1, { SDLK_h } },
    { EGOCODE_RIGHT_PACK,   1, { SDLK_n } },
    { EGOCODE_CAMERA_LEFT,  1, { SDLK_KP7 } },
    { EGOCODE_CAMERA_RIGHT, 1, { SDLK_KP9 } },
    { EGOCODE_MESSAGE,      1, { SDLK_m } },
    { EGOCODE_CAMERA_IN ,   1, { SDLK_KP_PLUS } },
    { EGOCODE_CAMERA_OUT ,  1, { SDLK_KP_MINUS } },
    { EGOCODE_ARROWUP ,     1, { SDLK_KP8 } },
    { EGOCODE_ARROWDOWN ,   1, { SDLK_KP2 } },
    { EGOCODE_ARROWLEFT ,   1, { SDLK_KP4 } },
    { EGOCODE_ARROWRIGHT ,  1, { SDLK_KP6 } },
    /* ---------- Default values for Player[2] -------- */
    { EGOCODE_JUMP,         2, { EVENT_MOU_MIDDLE } },
    { EGOCODE_LEFT_USE,     2, { SDLK_a } },
    { EGOCODE_LEFT_GET,     2, { EVENT_MOU_RIGHT, EVENT_MOU_MIDDLE } },
    { EGOCODE_LEFT_PACK,    2, { SDLK_s } },
    { EGOCODE_RIGHT_USE,    2, { EVENT_MOU_LEFT } },
    { EGOCODE_RIGHT_GET,    2, { EVENT_MOU_LEFT, EVENT_MOU_RIGHT  } },
    { EGOCODE_RIGHT_PACK,   2, { EVENT_MOU_FOURTH } },
    { EGOCODE_CAMERAMODE,   2, { EVENT_MOU_RIGHT } },
    { EGOCODE_MOVEMENT,     2, { EVENT_MOU_MOVE } }
    /* TODO: Fill in default values for the Joysticks
             in case of error reading the 'controls' */
   /*  {   , 0, {  } }, */


};

/*******************************************************************************
* CODE								                                       *
*******************************************************************************/

/*
 * Name:
 *     eventStr2SDLkey
 * Description:
 *     Translates a given 'key_name' into an SDLK_-value 
 * Input:
 *     key_name *: Pointer on name of key  
 */
int eventStr2SDLkey(char *key_name)
{ 

    CONTROL_NAME *ct;
    

    ct = &Control_Table[0];
    
    while (ct -> name[0] > 0) {

        if (! strcmp(ct -> name, key_name)) {
        
            return ct -> sdl_code;
            
        }
        
        ct++;
        
    }
    
    return 0;       /* No valid code */

}

/* ==================== Key and Command handling =================== */

/*
 * Name:
 *     eventCommandListPrepare
 * Description:
 *     Prepares the command list for the management with
 *     Remove the key(s) in 'act_cmd' from commands in command list.
 *     Excluding the given command, if it supports a 'release'-command.
 * Input:
 *     cmd_list *: Pointer on list of possible commands
 */
static void eventCommandListPrepare(EVENT_CMD *cmd_list)
{

    if (cmd_list) {
    
        while(cmd_list -> code > 0) {

            /* Reset from possible previous use */
            cmd_list -> pressed = 0;
            cmd_list++;
            
        }
       
    }

}

/*
 * Name:
 *     eventReleaseKeyFromCommand
 * Description:
 *     Does the work, if a key is released
 * Input:
 *     event *: To fill with data, if a command is found
 *     cmd_list *: Pointer on list of possible commands
 */
static int eventReleaseKeyFromCommand(EVENT_INFO *event, EVENT_CMD *cmd_list)
{

    EVENT_CMD *plist;


    if (! cmd_list) {

        return 1;

    }

    /* First step: Look up 'postselect'-keys */
    plist = cmd_list;
    while (plist -> code > 0) {

        /* --- Is it a 'postselect' key ? ----- */
        if (plist -> keys[1] == event -> sdlcode) {

            plist -> pressed &= ~EVENT_CMD_FPOSTSELECT;
            if (plist -> send_release > 0 && (plist -> pressed & EVENT_CMD_FPRESELECT)) {

                /* Caller wants to react on release of key */
                event -> code    = plist -> code;
                event -> subcode = plist -> subcode;
                return 1;
                
            }
            
        }
        
        plist++;

    }

    /* Second step: Look up 'preselect' key' */
    plist = cmd_list;
    while (plist -> code > 0) {

        /* --- Is it a 'preselect' key ? ----- */
        if (plist -> keys[0] == event -> sdlcode) {

            /* ---------- Remove flag for preselected key -- */
            plist -> pressed &= ~EVENT_CMD_FPRESELECT;
            if (plist -> keys[1] > 0 && (plist -> pressed & EVENT_CMD_FPOSTSELECT)) {

                plist -> pressed &= EVENT_CMD_FPOSTSELECT;
                if (plist -> send_release > 0) {

                    /* Caller wants to react on release of key  */
                    /* There can be only one                    */
                    event -> code    = plist -> code;
                    event -> subcode = plist -> subcode;

                }

            }
            else {

                /* It's a single key */
                if (plist -> send_release > 0) {

                    /* Caller wants to react on release of key */
                    /* There can be only one                    */
                    event -> code    = plist -> code;
                    event -> subcode = plist -> subcode;
                    return 1;

                }
                
            }    
            
        } /* if (plist -> keys[0] == key) */
        
        plist++;

    }
            
    return event -> code;

}


/*
 * Name:
 *     eventKeyToCommand
 * Description:
 *     Sets / removes a key from the command list
 * Input:
 *     event *: To fill with data, if a command is found
 *     cmd_list *:  Pointer on list of possible commands
 * Output:
 *     Command generated yes/no
 */
static int eventKeyToCommand(EVENT_INFO *event, EVENT_CMD *cmd_list)
{

    EVENT_CMD *plist;


    if (! cmd_list) {

        return 1;

    }

    /* ------- Handle released key --------- */
    if (! event -> pressed) {

        return eventReleaseKeyFromCommand(event, cmd_list);

    }

    /* First step: Look up 'postselect'-keys */
    plist = cmd_list;
    while (plist -> code > 0) {

        /* --- Is it a 'postselect' key ? ----- */
        if (plist -> keys[1] == event -> sdlcode) {

            plist -> pressed |= EVENT_CMD_FPOSTSELECT; /* Set the flag */

            if (plist -> pressed & EVENT_CMD_FPRESELECT) {

                /* -------- It's preselected -------- */
                event -> code    = plist -> code;
                event -> subcode = plist -> subcode;
                if (! plist -> send_release) {
                
                    /* Clear the flags */
                    plist -> pressed = 0;
                    
                }
                return 1;

            }

        }

        plist++;

    }

    /* Second step: Look up 'preselect' key */
    plist = cmd_list;
    while (plist -> code > 0) {

        /* --- Is it a 'preselect' or a 'single' key ? ----- */
        if (plist -> keys[0] == event -> sdlcode) {

            /* --- Is it a 'preselect' key ? ----- */
             if (plist -> keys[1] > 0) {

                /* If the first key is already pressed */
                plist -> pressed |= EVENT_CMD_FPRESELECT;

             }
             else {

                /* It's a 'single' key */
                event -> code    = plist -> code;
                event -> subcode = plist -> subcode;
                if (! plist -> send_release) {
                
                    /* Clear the flags */
                    plist -> pressed = 0;
                    
                }
                return 1;

            }

        }

        plist++;
        
    }
                
    return 0;

}

/*
 * Name:
 *     eventToKeyCommand
 * Description:
 *     Translates given device input to it depending on 'pressed'
 * Input:
 *     event *:    Pointer on event to handle
 *     ranges *:   To check for hot keys, if any
 *     cmd_list *: List of commands, if any
 * Output:
 *     Command generated yes/no
 */
static int eventToKeyCommand(EVENT_INFO *event, EVENT_RANGE *ranges, EVENT_CMD *cmd_list)
{

    /* First look for shortcuts in possible EVENT_RANGE's */
    if (ranges && event -> pressed) {

        while(ranges -> type) {

            if (ranges -> shortcut > 0) {

                if (event -> sdlcode == ranges -> shortcut) {

                    /* Key is single shortcut for this  field */
                    event -> code    = ranges -> code;
                    event -> subcode = ranges -> subcode;
                    event -> range   = ranges;
                    return 1;

                }

            }

            ranges++;

        }

    }

    /* --------- It's not used as a shortcut, stick it into the command list */
    eventKeyToCommand(event, cmd_list);

    return 0;

}

/* ===================== Range handling ============================ */

/*
 * Name:
 *     eventInRange
 * Description:
 *     Checks if the given x,y position is in the given mouvec-rect
 * Input:
 *     event *: Pointer on an event to fill code into, if any
 *     range *: Pointer on a range which holds the rectangle to check
 * Output:
 *     1: if Position in rect
 *     0: if not
 *     event: the xrel + yrel are set to the relative position in the
 *		 checked rectangle.
 */
static int eventInRange(EVENT_INFO *event, EVENT_RANGE *range)
{

    int posx,
        posy;		/* Relative position */


    /* First check horizontally */
    posx = event -> posx - range -> rect.x;

    if (posx >= 0) {			  /* Is right of X 		*/

        if (posx > range -> rect.w) {

            return 0;			  /* Right side out of Rectangle */

        }

        /* Now check vertically */
        posy = event -> posy - range -> rect.y;

    	if (posy >= 0) {		  /* Is lower of Y-Pos */

            if (posy <= range -> rect.h) {

                event -> posx = posx;
                event -> posy = posy;
            	return 1;			    /* Is in Rectangle   */

            }

    	}

    }
    
    return 0;

}

/*
 * Name:
 *     eventRangesToCommand
 * Description:
 *
 *     Translates mouse events to 'keys'
 *     Translates the mouse buttons for input in Ranges
 * Input:
 *     event *: Pointer on event struct holding info about mouse
 *     range *: For this range
 * Output:
 *     Command generated yes/no
 */
static int eventRangesToCommand(EVENT_INFO *event, EVENT_RANGE *ranges)
{

    /* The focus range holds a pointer on the actual range the mouse is over, if any */
    static EVENT_RANGE *CursorOver = &DefaultFocusRange;   /* Never NULL   */
    

    
    EVENT_RANGE *base;              /* Save base    */


    event -> range = 0;             /* Assume none  */

    /* If ranges are given, look them up top to bottom, if the mouse is here */
    if (ranges) {

        /* Search from top to bottom */
        base =  ranges;
        while (ranges -> type != 0) {

            ranges++;       /* Points on trailing type 0 */

        }

        while (ranges > base) {

            ranges--;

            /* If the given position is in a range */
            if (ranges -> code && eventInRange(event, ranges)) {

                /* Reset flag for position over */
                CursorOver -> fstate &= ~EVENT_FSTATE_MOUSEOVER;
                /* Set new position over flag   */
                CursorOver = ranges;
                CursorOver -> fstate |= EVENT_FSTATE_MOUSEOVER;

                if (event -> pressed > 0) {

                    EventFocus -> fstate &= ~EVENT_FSTATE_HASFOCUS;
                    EventFocus = ranges;
                    EventFocus -> fstate |= (EVENT_FSTATE_HASFOCUS | EVENT_FSTATE_MOUPRESSED);
                                        
                    event -> code    = ranges -> code;
                    event -> subcode = ranges -> subcode;
                    return 1;

                }

                /* Over a range, check no more */
                return 0;

            }

        }

    }

    return 0;

}

/* ====================== The main functions for translation ======== */    

/*
 * Name:
 *     eventMouseToEvent
 * Description:
 *     Translates an SDL Mouse-Event to an own 'event', using the info given int 'ranges'
 * Input:
 *     sdl_event *: Event to
 *     event *:    Pointer on event struct to fill with info generated from mouse event
 */
static void eventMouseToEvent(SDL_Event *sdl_event, EVENT_INFO *event)
{

    int result;


    switch(sdl_event -> type) {

        case SDL_MOUSEMOTION:
            /* Fill in the values into the 'event' struct */
            event -> posx  = sdl_event -> motion.x;
            event -> posy  = sdl_event -> motion.y;
            event -> movex = sdl_event -> motion.xrel;
            event -> movey = sdl_event -> motion.yrel;

            /* Create the special key, if needed as key */
            if (sdl_event -> motion.state & SDL_BUTTON_LMASK) {

                event -> pressed = 1;    
                event -> sdlcode = EVENT_MOU_LDRAG;
                
            }
            else if (sdl_event -> motion.state & SDL_BUTTON_RMASK) {
                
                event -> pressed = 1;        
                event -> sdlcode = EVENT_MOU_RDRAG;
                     
            }
            else {
                    
                event -> pressed = 0;        
                event -> sdlcode = EVENT_MOU_MOVE;  /* Ignore it, just movement */
                        
            }
                                    
            if (eventRangesToCommand(event, pRanges)) {
                
                if (event -> pressed) {
                                   
                    return;
                    
                }
           
            }

            /* In any other case, it's a simple mouse movement ==> key */
            event -> pressed = 1;   /* For key handling */
            eventKeyToCommand(event, pCmdList);
            break;

        case SDL_MOUSEBUTTONDOWN:
        case SDL_MOUSEBUTTONUP:
            event -> posx    = sdl_event -> button.x;
            event -> posy    = sdl_event -> button.y;
            
            if (sdl_event ->type == SDL_MOUSEBUTTONDOWN) {

                event -> pressed = 1;
                result = eventRangesToCommand(event, pRanges);

            }
            else {

                event -> pressed = 0;
                result = 0;
                /* FIXME: Signal for Button-up ? */

            }

            if (! result) {

                /* Translate is as simple key */
                switch(sdl_event -> button.button) {

                    case SDL_BUTTON_LEFT:
                        event -> sdlcode = EVENT_MOU_LEFT;
                        break;
                    case SDL_BUTTON_RIGHT:
                        event -> sdlcode = EVENT_MOU_RIGHT;
                        break;
                    case SDL_BUTTON_MIDDLE:
                        event -> sdlcode = EVENT_MOU_MIDDLE;
                        break;

                }

                eventKeyToCommand(event, pCmdList);

            }
            break;

    }

}

/*
 * Name:
 *     eventKeyboardToEvent
 * Description:
 *     Translates an SDL-Input into an 'event',
 * Input:
 *     sdl_event *: Pointer on event to translate
 *     event *:    Translated result
 */
static void eventKeyboardToEvent(SDL_Event *sdl_event, EVENT_INFO *event)
{

    EVENT_SHIFTVAL *sv;


    /* Fill in the 'raw' data */
    event -> sdlcode  = sdl_event -> key.keysym.sym;
    event -> modflags = sdl_event -> key.keysym.mod;

    /* Translate it to Standard-Keyboard input for 'text-mode' */
    event -> textkey = (char)event -> sdlcode;

    if (event -> modflags & KMOD_SHIFT) {

        event -> textkey = (char)toupper(event -> textkey);

    }
    else {

        sv = &Shift_Char_Lut[0];
        while (sv -> sdlkey > 0) {

            if (sv -> sdlkey == event -> sdlcode) {

                event -> textkey = sv -> shiftkey;
                break;

            }

            sv++;

        }

    }

    /* Translate it to a command, if possible */
    if (sdl_event -> type == SDL_KEYDOWN) {

        event -> pressed = 1;

    }
    else {

        event -> pressed = 0;

    }

    eventToKeyCommand(event, pRanges, pCmdList);

}

/*
 * Name:
 *     eventJoystickToEvent
 * Description:
 *     Translates given device input to
 *     it depending on 'pressed'
 * Input:
 *     sdl_event *: SDL-Event to translate internal event
 *     event *:     Struct to fill in
 */
static void eventJoystickToEvent(SDL_Event *sdl_event, EVENT_INFO *event)
{

    switch(sdl_event -> type) {

        case SDL_JOYAXISMOTION:
            /* Translate the axis */
            if (sdl_event -> jaxis.axis == 0) {

                event -> movex = sdl_event -> jaxis.value;

            }
            else if (sdl_event -> jaxis.axis == 1) {

                event -> movey = sdl_event -> jaxis.value;

            }

            if (sdl_event -> jaxis.which == 0) {

                event -> sdlcode = EVENT_JOY_A_MOVE;

            }

            if (sdl_event -> jaxis.which == 1) {

                event -> sdlcode = EVENT_JOY_B_MOVE;

            }
            eventKeyToCommand(event, pCmdList);
            break;

        case SDL_JOYBUTTONDOWN:
        case SDL_JOYBUTTONUP:
            if (sdl_event -> jbutton.which == 0) {

                event -> sdlcode = EVENT_JOY_A_0 + sdl_event -> jbutton.button;

            }

            if (sdl_event -> jbutton.which == 1) {

                event -> sdlcode = EVENT_JOY_B_0 + sdl_event -> jbutton.button;

            }

            if (sdl_event -> type == SDL_JOYBUTTONDOWN) {

                event -> pressed = 1;

            }
            else {

                event -> pressed = 0;

            }
            
            eventKeyToCommand(event, pCmdList);
            break;

    }

}

/* ==================== Main translation function ================ */

/*
 * Name:
 *     eventInputToEvent
 * Description:
 *     Polls all input devices and stores the translated result 
 *     in an in an EVENT_INFO-struct.
 *     Merges the different types of input into one single type
 *     If a valid 'command' could be generated, events left from SLD
 *     are ignored.
 * Input:
 *     ego_event *: Pointer on struct to fill with command info
 * Output:
 *     All non-zero-code signals a valid 'ego_event' is generated
 */
static int eventInputToEvent(EVENT_INFO *ego_event)
{

    static int mouse_moved = 0;

    SDL_Event  sdlevent;


    /* -------- Clear event buffer --------- */
    memset(ego_event, 0, sizeof(EVENT_INFO));

    /* ------ Mimick 'release' of 'EVENT_MOU_MOVE' ----------- */
    if (mouse_moved) {

        ego_event -> sdlcode = EVENT_MOU_MOVE;
        eventKeyToCommand(ego_event, pCmdList);

        mouse_moved = 0;
        
        return ego_event -> code;

    }

    while ( SDL_PollEvent(&sdlevent) ) {

        if (! ego_event -> code) {

            switch(sdlevent.type) {

                case SDL_QUIT:
                    ego_event -> code = EGOCODE_QUITTOOS;
                	return EGOCODE_QUITTOOS;

                case SDL_MOUSEMOTION:
                    mouse_moved = 1;        /* For mimicking 'release' */
                case SDL_MOUSEBUTTONDOWN:
                case SDL_MOUSEBUTTONUP:
                    eventMouseToEvent(&sdlevent, ego_event);
                    break;

                case SDL_KEYDOWN:
                case SDL_KEYUP:
                    /* Translate input keys */
                    eventKeyboardToEvent(&sdlevent, ego_event);
                    break;

                case SDL_JOYAXISMOTION:
                case SDL_JOYBUTTONDOWN:
                case SDL_JOYBUTTONUP:
                    eventJoystickToEvent(&sdlevent, ego_event);
                    break;
                default:
                     /* Ignore it */
                     break;


            }   /* switch(event.type) */

        }
        else {  /* if (! ego_event -> code) { */

                /* Do nothing at all, if already a code has been generated */
                /* Just remove it from buffer                              */
                /* Return 'invalid command'                                */
                ego_event -> code = -1;

        }

    }  	/* while (SDL_PollEvent(&event)) */

    return ego_event -> code;

}


/*
 * Name:
 *     eventCommand2Latch
 * Description:
 *     Translates given command into a latch bit and sets/removes
 *     it depending on 'pressed'
 * Input:
 *     cmd_code: To translate
 *     pressed:  yes/no
 *     latchbutton *: Pointer on latch bits array to adjust accordingly
 *
 */
static void eventCommand2Latch(int cmd_code, char pressed, unsigned char *latchbutton)
{
    
    unsigned char latchbit;

    
    latchbit = 0;
    switch(cmd_code) {
        case EGOCODE_JUMP:  
            latchbit = LATCHBUTTONJUMP;
            break;

        case EGOCODE_LEFT_USE:
            latchbit = LATCHBUTTONLEFT; 
            break;           
        case EGOCODE_RIGHT_USE:
            latchbit = LATCHBUTTONRIGHT;
            break;
        case EGOCODE_LEFT_PACK:
            latchbit = LATCHBUTTONPACKLEFT;
            break;
        case EGOCODE_RIGHT_PACK:
            latchbit = LATCHBUTTONPACKRIGHT;
            break;
        case EGOCODE_LEFT_GET:
            latchbit = LATCHBUTTONALTLEFT;
            break;        
        case EGOCODE_RIGHT_GET:
            latchbit = LATCHBUTTONALTRIGHT;
            break;
        case EGOCODE_RESPAWN:
            latchbit = LATCHBUTTONRESPAWN;
            break;
        default:
            /* Invalid Code */ 
            return;
       
    }
    
    if (pressed) {
    
        *latchbutton |= latchbit;
        
    }
    else {

        *latchbutton &= latchbit;

    }

}

/* ========================================================================== */
/* ======================== PUBLIC FUNCTIONS	============================= */
/* ========================================================================== */

/*
 * Name:
 *     eventInitJoysticks
 * Description:
 *     Has to be called before 'event'-s are used, if joysticks have to
 *     be supported by this module.
 *     Inits the info for the joysticks numbers and availability. This is
 *     needed for reading joystick info from SDL-events.
 * Input:
 *     None
 */
void eventSetJoystickInfo(void)
{

    if ( SDL_NumJoysticks() > 0 ) {
    
        JoyStick[0].sdl_device = SDL_JoystickOpen( 0 );
        JoyStick[0].on = (NULL != JoyStick[0].sdl_device);


        if ( SDL_NumJoysticks() > 1 ) {

            JoyStick[1].sdl_device = SDL_JoystickOpen( 1 );
            JoyStick[1].on = (NULL != JoyStick[1].sdl_device);

        }

        /* Enable handling of joystick using 'SDL_event' */
        SDL_JoystickEventState(SDL_ENABLE);

    }

}


/*
 * Name:
 *     eventSetInputTable
 * Description:
 *     Sets the input to given 'range' and 'cmdkeys', if any.
 *     If two NULL-Pointer are given, the 'cmdkeys' are set on a default function.
 * Input:
 *     key_name *: Pointer on name of key
 */
void eventSetInputTable(EVENT_RANGE *range, EVENT_CMD *cmdkeys)
{

    SDL_Event  sdl_event;

    
    /* ----- Clear SDL Inputbuffer ---- */
    while ( SDL_PollEvent(&sdl_event) );
    /* ----- Set pointers on lists to look up */
    pRanges  = range;
    pCmdList = cmdkeys;
    /* ----- Prepare the command list for management ---- */
    eventCommandListPrepare(cmdkeys);    

}

/*
 * Name:
 *     eventGetInput
 * Description:
 *     Returns > 0 if an event is generated
 * Input:
 *     event *: Where to return the translated event
 * Output:
 *     Event generated, yes/no
 */
int eventGetInput(EVENT_INFO *event)
{

     return eventInputToEvent(event);

}

/*
 * Name:
 *     eventSetGameInputTable
 * Description:
 *     Sets the internal pointers on the input tables to the game commands
 * Input:
 *     None
 */
void eventSetGameInputTable(void)
{

    SDL_Event  sdl_event;


    /* ----- Clear SDL Inputbuffer ---- */
    while ( SDL_PollEvent(&sdl_event) );
    /* ----- Set pointers on lists to look up */
    pRanges = 0;
    pCmdList = &Command_List[0];    /* The given game-commands  */

    /* ----- Prepare the command list for management ---- */
    eventCommandListPrepare(&Command_List[0]);     
    
}

/*
 * Name:
 *     eventTranslateGameInput
 * Description:
 *     Translates the input to game commands and calls the game functions
 *     depending on the command.
 *     Uses the pointers set using procedure 'eventSetGameInputTable()'
 * Input:
 *     None
 * Output:
 *     Done signal, yes/no
 */
int eventTranslateGameInput(EVENT_INFO *event)
{

    unsigned char latches;


    eventInputToEvent(event);

    if (event -> code > 0) {

        switch(event -> code) {

            case EGOCODE_QUITMODULE:
                return 1;           /* Done with module */

            /* set_one_player_latch(PLAYER *pplayer); */
            case EGOCODE_JUMP:
            case EGOCODE_LEFT_USE:
            case EGOCODE_LEFT_GET:
            case EGOCODE_LEFT_PACK:
            case EGOCODE_RIGHT_USE:
            case EGOCODE_RIGHT_GET:
            case EGOCODE_RIGHT_PACK:
            case EGOCODE_RESPAWN:
                eventCommand2Latch(event -> code, 1, &latches);
                /*
                   'event -> subcode' is the number of the player */
                /* set_one_player_latch(int character_no, unsigned char latchbutton,
                                        char latchpressed, int movex, int movey); */
                /* set_one_player_latch()  */
                /* FIXME: Release latches */
                break;

            case EGOCODE_MESSAGE:
                /* Call 'message'-Code */
                break;
            case EGOCODE_CAMERA_LEFT:
            case EGOCODE_CAMERA_RIGHT:
            case EGOCODE_CAMERA_IN:
            case EGOCODE_CAMERA_OUT:
                /* eventKeysToCamera(event.code) */
                /* camera_move(int movex, int movey, int playerno/camerano);      */
                /* camera_move(event.movex, event.movey, event.subcode); */
                break;

            case EGOCODE_CAMERAMODE:
                /* Set flag for this player press/release */
                Player[event -> subcode].cameramode = event -> pressed;
                break;
                
            case EGOCODE_MOVEMENT:
                /* Mouse or joystick generate this one */
                /* FIXME: Adjust movement for mouse/joystick */
                if (Player[event -> subcode].cameramode) {
                    
                    /* camera_move(event -> movex, event -> movey, event -> subcode);      *
                    /* camera_move(int movex, int movey, int playerno/camerano);      */
                    
                }
                else {
                    
                    /* set_one_player_latch(Player[event -> subcode].index, 0, 0, event -> movex, event -> movey) */   
                    /* set_one_player_latch(int character_no, unsigned char latchbutton, int movex, int movey); */    
                      
                }
                break;
            case EGOCODE_ARROWUP:
            case EGOCODE_ARROWDOWN:
            case EGOCODE_ARROWLEFT:
            case EGOCODE_ARROWRIGHT:            
                /* TODO: Calculate the  movement */ 
                /* set_one_player_latch(int character_no, unsigned char latchbutton, int movex, int movey); */ 
                /* set_one_player_latch(Player[event -> subcode].index, 0, event -> movex, event -> movey); */    
                break;
            case EGOCODE_SHOWSTAT_LSHIFT:   
                /* LEFT SHIFT   + 1 to 7 - Show selected character armor without magic enchants */
                /* show_armor(event -> subcode) */
                break;
            case EGOCODE_SHOWSTAT_LCTRL:
                /* LEFT CONTROL + 1 to 7 - Show armor stats with magic enchants included */
                /* show_full_status(event -> subcode) */
                break;
            case EGOCODE_SHOWSTAT_LALT:   
                /* LEFT ALT     + 1 to 7 - Show character magic enchants    */
                /* show_magic_status(event -> subcode) */
                break;
            case EGOCODE_SHOWSTAT:
                /* Show character detailed stats */
                /* show_stat(event -> subcode) */
                break;
            case EGOCODE_GIVEEXPERIENCE:
                /* SDLK_x: SDLK_1 / SDLK_2 */
                /* Experience cheat */
                /* give_experience( plaindex[0], 25, XPDIRECT ); */
                break;
            case EGOCODE_MAPCHEAT:
                /* ----------- */
                /* SDLKEYDOWN( SDLK_m ) && SDLKEYDOWN( SDLK_LSHIFT ) */
                /* mapon = mapvalid; youarehereon = btrue; */
                break;
            case EGOCODE_LIFECHEAT:
                /* SDLKEYDOWN( SDLK_z ) + SDLKEYDOWN( SDLK_1 ) */
                /* chrlife[plaindex[0]] += 128; */
                break;
                
        } /* switch */
        
    } /* if (event.code) */
    
    return 0;

}

/*
 * Name:
 *     eventReadControls
 * Description:
 *     Reads in the 'controls.cfg'-File and fills in the 'Command_List'
 * Input:
 *     None
 */
void eventReadControls(void)
{

    EVENT_CMD *pcmdlist;
    
    
    pcmdlist = &Command_List[0];
    while(pcmdlist -> code != 0) {
    
        if (pcmdlist -> code == EGOCODE_JUMP) {
        
            while(pcmdlist -> code != 0) {

                 /* TODO: Fill in the commands from 'controls.cfg' */

            }

            return;

        }

        pcmdlist++;
        
    }

}

/*
 * Name:
 *     eventReadConfig
 * Description:
 *     Reads in the general configuration data
 * Input:
 *     None TODO: Hand over the GameInfo-Struct
 */
void eventReadConfig(void)
{

    /* TODO: Read in the configuration */
    
}