<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>modbaker: /media/disk/Projects/egoboo_svn/branches/tobiasgall/modbaker/src/frustum.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>/media/disk/Projects/egoboo_svn/branches/tobiasgall/modbaker/src/frustum.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef frustum_h</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define frustum_h</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="comment">// We create an enum of the sides so we don't have to call each side 0 or 1.</span>
<a name="l00004"></a>00004 <span class="comment">// This way it makes it more understandable and readable when dealing with frustum sides.</span>
<a name="l00005"></a>00005 <span class="keyword">enum</span> e_frustum_side
<a name="l00006"></a>00006 {
<a name="l00007"></a>00007     RIGHT = 0,  
<a name="l00008"></a>00008     LEFT = 1,   
<a name="l00009"></a>00009     BOTTOM = 2, 
<a name="l00010"></a>00010     TOP  = 3,   
<a name="l00011"></a>00011     BACK = 4,   
<a name="l00012"></a>00012     FRONT = 5   
<a name="l00013"></a>00013 };
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="keyword">typedef</span> <span class="keyword">enum</span> e_frustum_side FrustumSide;
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="comment">// Like above, instead of saying a number for the ABC and D of the plane, we</span>
<a name="l00018"></a>00018 <span class="comment">// want to be more descriptive.</span>
<a name="l00019"></a>00019 <span class="keyword">enum</span> e_plane_data
<a name="l00020"></a>00020 {
<a name="l00021"></a>00021     A = 0,    
<a name="l00022"></a>00022     B = 1,    
<a name="l00023"></a>00023     C = 2,    
<a name="l00024"></a>00024     D = 3     
<a name="l00025"></a>00025 };
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="keyword">typedef</span> <span class="keyword">enum</span> e_plane_data PlaneData;
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="keyword">typedef</span> <span class="keywordtype">float</span> frustum_data_t[6][4];
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="keyword">class </span>c_frustum
<a name="l00032"></a>00032 {
<a name="l00033"></a>00033     <span class="keyword">private</span>:
<a name="l00034"></a>00034         frustum_data_t planes;
<a name="l00035"></a>00035 
<a name="l00036"></a>00036     <span class="keyword">public</span>:
<a name="l00037"></a>00037         <span class="keywordtype">void</span> NormalizePlane(FrustumSide);
<a name="l00038"></a>00038         <span class="keywordtype">void</span> CalculateFrustum(<span class="keywordtype">float</span> *, <span class="keywordtype">float</span> *);
<a name="l00039"></a>00039         <span class="keywordtype">bool</span> PointInFrustum(<span class="keywordtype">float</span> *);
<a name="l00040"></a>00040         <span class="keywordtype">bool</span> SphereInFrustum(<span class="keywordtype">float</span> *, <span class="keywordtype">float</span>);
<a name="l00041"></a>00041         <span class="keywordtype">bool</span> CubeInFrustum(<span class="keywordtype">float</span> *, <span class="keywordtype">float</span>);
<a name="l00042"></a>00042         <span class="keywordtype">bool</span> BBoxInFrustum(<span class="keywordtype">float</span> *, <span class="keywordtype">float</span> *);
<a name="l00043"></a>00043 };
<a name="l00044"></a>00044 <span class="preprocessor">#endif</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00046"></a>00046 
<a name="l00048"></a>00048 <span class="comment">//</span>
<a name="l00049"></a>00049 <span class="comment">// * QUICK NOTES *</span>
<a name="l00050"></a>00050 <span class="comment">//</span>
<a name="l00051"></a>00051 <span class="comment">// WOZZERS!  That seemed like an incredible amount to look at, but if you break it</span>
<a name="l00052"></a>00052 <span class="comment">// down, it's not.  Frustum culling is a VERY useful thing when it comes to 3D.</span>
<a name="l00053"></a>00053 <span class="comment">// If you want a large world, there is no way you are going to send it down the</span>
<a name="l00054"></a>00054 <span class="comment">// 3D pipeline every frame and let OpenGL take care of it for you.  That would</span>
<a name="l00055"></a>00055 <span class="comment">// give you a 0.001 frame rate.  If you hit '+' and bring the sphere count up to</span>
<a name="l00056"></a>00056 <span class="comment">// 1000, then take off culling, you will see the HUGE difference it makes.</span>
<a name="l00057"></a>00057 <span class="comment">// Also, you wouldn't really be rendering 1000 spheres.  You would most likely</span>
<a name="l00058"></a>00058 <span class="comment">// use the sphere code for larger objects.  Let me explain.  Say you have a bunch</span>
<a name="l00059"></a>00059 <span class="comment">// of objects, well... all you need to do is give the objects a radius, and then</span>
<a name="l00060"></a>00060 <span class="comment">// test that radius against the frustum.  If that sphere is in the frustum, then you</span>
<a name="l00061"></a>00061 <span class="comment">// render that object.  Also, you won't be rendering a high poly sphere so it won't</span>
<a name="l00062"></a>00062 <span class="comment">// be so slow.  This goes for bounding box's too (Cubes).  If you don't want to</span>
<a name="l00063"></a>00063 <span class="comment">// do a cube, it is really easy to convert the code for rectangles.  Just pass in</span>
<a name="l00064"></a>00064 <span class="comment">// a width and height, instead of just a length.  Remember, it's HALF the length of</span>
<a name="l00065"></a>00065 <span class="comment">// the cube, not the full length.  So it would be half the width and height for a rect.</span>
<a name="l00066"></a>00066 <span class="comment">//</span>
<a name="l00067"></a>00067 <span class="comment">// This is a perfect starter for an octree tutorial.  Wrap you head around the concepts</span>
<a name="l00068"></a>00068 <span class="comment">// here and then see if you can apply this to making an octree.  Hopefully we will have</span>
<a name="l00069"></a>00069 <span class="comment">// a tutorial up and running for this subject soon.  Once you have frustum culling,</span>
<a name="l00070"></a>00070 <span class="comment">// the next step is getting space partitioning.  Either it being a BSP tree of an Octree.</span>
<a name="l00071"></a>00071 <span class="comment">//</span>
<a name="l00072"></a>00072 <span class="comment">// Let's go over a brief overview of the things we learned here:</span>
<a name="l00073"></a>00073 <span class="comment">//</span>
<a name="l00074"></a>00074 <span class="comment">// 1) First we need to abstract the frustum from OpenGL.  To do that we need the</span>
<a name="l00075"></a>00075 <span class="comment">//    projection and modelview matrix.  To get the projection matrix we use:</span>
<a name="l00076"></a>00076 <span class="comment">//</span>
<a name="l00077"></a>00077 <span class="comment">//   glGetFloatv( GL_PROJECTION_MATRIX, /* An Array of 16 floats */ );</span>
<a name="l00078"></a>00078 <span class="comment">//    Then, to get the modelview matrix we use:</span>
<a name="l00079"></a>00079 <span class="comment">//</span>
<a name="l00080"></a>00080 <span class="comment">//   glGetFloatv( GL_MODELVIEW_MATRIX, /* An Array of 16 floats */ );</span>
<a name="l00081"></a>00081 <span class="comment">//</span>
<a name="l00082"></a>00082 <span class="comment">//   These 2 functions gives us an array of 16 floats (The matrix).</span>
<a name="l00083"></a>00083 <span class="comment">//</span>
<a name="l00084"></a>00084 <span class="comment">// 2) Next, we need to combine these 2 matrices.  We do that by matrix multiplication.</span>
<a name="l00085"></a>00085 <span class="comment">//</span>
<a name="l00086"></a>00086 <span class="comment">// 3) Now that we have the 2 matrixes combined, we can abstract the sides of the frustum.</span>
<a name="l00087"></a>00087 <span class="comment">//    This will give us the normal and the distance from the plane to the origin (ABC and D).</span>
<a name="l00088"></a>00088 <span class="comment">//</span>
<a name="l00089"></a>00089 <span class="comment">// 4) After abstracting a side, we want to normalize the plane data.  (A B C and D).</span>
<a name="l00090"></a>00090 <span class="comment">//</span>
<a name="l00091"></a>00091 <span class="comment">// 5) Now we have our frustum, and we can check points against it using the plane equation.</span>
<a name="l00092"></a>00092 <span class="comment">//    Once again, the plane equation (A*x + B*y + C*z + D = 0) says that if, point (X,Y,Z)</span>
<a name="l00093"></a>00093 <span class="comment">//    times the normal of the plane (A,B,C), plus the distance of the plane from origin,</span>
<a name="l00094"></a>00094 <span class="comment">//    will equal 0 if the point (X, Y, Z) lies on that plane.  If it is behind the plane</span>
<a name="l00095"></a>00095 <span class="comment">//    it will be a negative distance, if it's in front of the plane (the way the normal is facing)</span>
<a name="l00096"></a>00096 <span class="comment">//    it will be a positive number.</span>
<a name="l00097"></a>00097 <span class="comment">//</span>
<a name="l00098"></a>00098 <span class="comment">//</span>
<a name="l00099"></a>00099 <span class="comment">// If you need more help on the plane equation and why this works, download our</span>
<a name="l00100"></a>00100 <span class="comment">// Ray Plane Intersection Tutorial at www.GameTutorials.com.</span>
<a name="l00101"></a>00101 <span class="comment">//</span>
<a name="l00102"></a>00102 <span class="comment">// That's pretty much it with frustums.  There is a lot more we could talk about, but</span>
<a name="l00103"></a>00103 <span class="comment">// I don't want to complicate this tutorial more than I already have.</span>
<a name="l00104"></a>00104 <span class="comment">//</span>
<a name="l00105"></a>00105 <span class="comment">// I want to thank Mark Morley for his tutorial on frustum culling.  Most of everything I got</span>
<a name="l00106"></a>00106 <span class="comment">// here comes from his teaching.  If you want more in-depth, visit his tutorial at:</span>
<a name="l00107"></a>00107 <span class="comment">//</span>
<a name="l00108"></a>00108 <span class="comment">// http://www.markmorley.com/opengl/frustumculling.html</span>
<a name="l00109"></a>00109 <span class="comment">//</span>
<a name="l00110"></a>00110 <span class="comment">// Good luck!</span>
<a name="l00111"></a>00111 <span class="comment">//</span>
<a name="l00112"></a>00112 <span class="comment">//</span>
<a name="l00113"></a>00113 <span class="comment">// Ben Humphrey (DigiBen)</span>
<a name="l00114"></a>00114 <span class="comment">// Game Programmer</span>
<a name="l00115"></a>00115 <span class="comment">// DigiBen@GameTutorials.com</span>
<a name="l00116"></a>00116 <span class="comment">// Co-Web Host of www.GameTutorials.com</span>
<a name="l00117"></a>00117 <span class="comment">//</span>
<a name="l00118"></a>00118 <span class="comment">//</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Jul 19 18:24:08 2009 for modbaker by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
